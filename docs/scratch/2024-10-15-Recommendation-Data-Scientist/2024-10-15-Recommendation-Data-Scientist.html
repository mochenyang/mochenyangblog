<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.54">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-10-15">
<meta name="description" content="Principles and Guidelines">

<title>Effective Communications as Data Scientists – Mochen’s Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Mochen’s Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/mochenyang"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#the-four-horsemen-of-communications" id="toc-the-four-horsemen-of-communications" class="nav-link active" data-scroll-target="#the-four-horsemen-of-communications">The Four Horsemen of Communications</a>
  <ul class="collapse">
  <li><a href="#the-first-horseman-being-too-technical" id="toc-the-first-horseman-being-too-technical" class="nav-link" data-scroll-target="#the-first-horseman-being-too-technical">The First Horseman: Being Too Technical</a></li>
  <li><a href="#the-second-horseman-recommendations-in-a-vacuum" id="toc-the-second-horseman-recommendations-in-a-vacuum" class="nav-link" data-scroll-target="#the-second-horseman-recommendations-in-a-vacuum">The Second Horseman: Recommendations in a Vacuum</a></li>
  <li><a href="#the-third-horseman-jumping-to-conclusions" id="toc-the-third-horseman-jumping-to-conclusions" class="nav-link" data-scroll-target="#the-third-horseman-jumping-to-conclusions">The Third Horseman: Jumping to Conclusions</a>
  <ul class="collapse">
  <li><a href="#symptom-1-making-recommendations-that-are-too-big" id="toc-symptom-1-making-recommendations-that-are-too-big" class="nav-link" data-scroll-target="#symptom-1-making-recommendations-that-are-too-big">Symptom 1: Making Recommendations that are “Too Big”</a></li>
  <li><a href="#symptom-2-making-recommendations-without-sufficient-evidence" id="toc-symptom-2-making-recommendations-without-sufficient-evidence" class="nav-link" data-scroll-target="#symptom-2-making-recommendations-without-sufficient-evidence">Symptom 2: Making Recommendations without Sufficient Evidence</a></li>
  </ul></li>
  <li><a href="#the-four-horseman-lack-of-attention-to-aesthetics" id="toc-the-four-horseman-lack-of-attention-to-aesthetics" class="nav-link" data-scroll-target="#the-four-horseman-lack-of-attention-to-aesthetics">The Four Horseman: Lack of Attention to Aesthetics</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Effective Communications as Data Scientists</h1>
  <div class="quarto-categories">
    <div class="quarto-category">exposition</div>
  </div>
  </div>

<div>
  <div class="description">
    Principles and Guidelines
  </div>
</div>


<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 15, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<blockquote class="blockquote">
<p><strong>Acknowledgment</strong>: This blog post is in collaboration with <a href="https://www.linkedin.com/in/leecthomas/">Lee Thomas</a> (Senior Director, Professional Communication, Carlson School of Management). Its intended audience is students in the MSBA program.</p>
</blockquote>
<blockquote class="blockquote">
<p>“<em>Your strategy is only as good as your ability to articulate it.</em>” – Bob Iger, CEO of Walt Disney</p>
</blockquote>
<p>One of the most important skills of a successful data scientist is the ability to communicate one’s data analytics solutions to a managerial / executive audience. Being able to communicate effectively and convincingly can lead to acceptance of one’s solutions, whereas ineffective communication fails to result in productive decisions.</p>
<p>At the same time, communication is also among the most under-recognized / under-appreciated skills, especially for MSBA students with limited professional experiences. Far too often, students subscribe to a “technical myth” where hard-core technical skills (e.g., coding, building fancy deep learning / AI models) are excessively valued over skills that are perceived to be “softer” (including presentation, team / project management, and communication). The myth is quickly busted when students need to communicate their data analytics effort in front of a managerial audience, only to find that they cannot seem to get the core messages across the room.</p>
<p>The purpose of this blog post is to discuss a few broadly applicable principles and guidelines of effective communications as data scientists. We do not claim that simply following these principles and guidelines would automatically create the prefect executive summaries or flawless presentations – there is no “magic formula” for effective communications. However, we hope to at least navigate you away from common pitfalls and mistakes that we have frequently observed in the past.</p>
<p>It is worth noting that Lee has created an “ABCD” framework, highlighting four crucial and productive strategies for effective communication: (<strong>A</strong>)dapt to the Audience, (<strong>B</strong>)etter than Before, (<strong>C</strong>)onvincing Content, and (<strong>D</strong>)esign &amp; Delivery. This blog post should be treated as a supplement to the “ABCD” framework.</p>
<section id="the-four-horsemen-of-communications" class="level1">
<h1>The Four Horsemen of Communications</h1>
<p>Over a number of years teaching and coaching MSBA students, we have distilled four most common mistakes people make when communicating their data analytics work. Colloquially, we refer to them as the “four horsemen of communications”. Loosely speaking, they each correspond to one element of the “ABCD” framework, but focuses on what <em>not</em> to do.</p>
<section id="the-first-horseman-being-too-technical" class="level2">
<h2 class="anchored" data-anchor-id="the-first-horseman-being-too-technical">The First Horseman: Being Too Technical</h2>
<p>Being too technical in a written report (e.g., an executive summary) or a verbal presentation means you are using technical concepts or terms without providing sufficient explanations for what they mean. As a student, you may well be familiar with various data science terminologies, but your audience may not be. Effective communications start with “meeting your audience where they are”, and that requires refraining from throwing out technical terms as if everybody should already understand them.</p>
<p>It is important to point out that “not being too technical” is different from “let’s dumb everything down and not use technical terms at all”. The complexity of real-world analytics problems usually necessitate some levels of technicality. The key is to provide enough contexts and intuitions to help your audience understand your work.</p>
<p>Think about the following two (contrasting) examples of reporting model selection results in the context of predicting sales leads:</p>
<blockquote class="blockquote">
<p><strong>Example 1.1</strong>: We perform model selection based on AUC, and the best predictive model achieves an AUC score of 0.9.</p>
</blockquote>
<p>vs.</p>
<blockquote class="blockquote">
<p><strong>Example 1.2</strong>: We select the best predictive model based on a metric called Area-under-the-Curve (AUC), which reflects a model’s ability to correctly prioritizing a more promising sales lead ahead of a less promising one. The metric takes value between 0 and 1, with higher value indicating better performance. Our best model achieves an AUC score of 0.9.</p>
</blockquote>
<p>It should be clear that example 2 is better and more understandable, even though both contain the same information from a technical perspective. It is worth noting that example 2 does not shy away from mentioning technical terms such as AUC, but provides sufficient explanation under the specific context of the task to facilitate understanding.</p>
</section>
<section id="the-second-horseman-recommendations-in-a-vacuum" class="level2">
<h2 class="anchored" data-anchor-id="the-second-horseman-recommendations-in-a-vacuum">The Second Horseman: Recommendations in a Vacuum</h2>
<p>How can you convince your audience that your solution to a problem is “good”? We get this type of questions every year. The reality is, it is often not meaningful to talk about the “good” or “bad” of a solution in a vacuum. Instead, a good solution is typically one that <em>improves</em> upon the pre-existing solution. For example, a “good” clustering solution is one that reveals some patterns in the data that we previously don’t know about, and a “good” predictive model may be one that achieves higher performance (on a particular metric of choice) than our currently deployed model.</p>
<p>This is exactly what the “better than before” element in the “ABCD” framework is about. However, very often, we observe students making recommendations that fail to highlight this aspect.</p>
<p>Take the example previous model selection example:</p>
<blockquote class="blockquote">
<p><strong>Example 2.1</strong>: We perform model selection based on AUC, and the best predictive model achieves an AUC score of 0.9.</p>
</blockquote>
<p>Is 0.9 AUC good or bad? It’s hard to say. Although 0.9 seems to be a large number (being close to 1), there really is no way to tell how “impressive” this model is, unless you provide some perspective to compare with. The following re-write improves on this aspect:</p>
<blockquote class="blockquote">
<p><strong>Example 2.2</strong>: We perform model selection based on AUC, and the best predictive model achieves an AUC score of 0.9. The previously deployed model achieves 0.8 AUC score on the same testing data, which means that our new model improves performance by a significant margin.</p>
</blockquote>
<p>Furthermore, if there are opportunities to “translate” model performance improvement to economic / business values, then doing so creates an even stronger message (e.g., the improvement of AUC from 0.8 to 0.9 roughly corresponds to an annual additional revenue of $xyz).</p>
<p>This applies to exploratory analytics as well (even though model evaluations tend to be subjective). Below is an example:</p>
<blockquote class="blockquote">
<p><strong>Example 2.3</strong>: We conduct a clustering analysis on the customer base, and discover three unique types of customer groups, which we term as high-spenders, low-spenders, and coupons-lovers.</p>
</blockquote>
<p>vs.&nbsp;</p>
<blockquote class="blockquote">
<p><strong>Example 2.4</strong>: We conduct a clustering analysis on the customer base, and discover three unique types of customer groups, which we term as high-spenders, low-spenders, and coupons-lovers. Notably, the “coupon-lovers” cluster features customers who tend to have high spending on discounted product categories using coupons, but have low spending on other product categories. This group of customers was previously included as a part of either high-spenders or low-spenders. We believe acknowledging them separately can help create meaningful marketing promotion strategies down the line.</p>
</blockquote>
</section>
<section id="the-third-horseman-jumping-to-conclusions" class="level2">
<h2 class="anchored" data-anchor-id="the-third-horseman-jumping-to-conclusions">The Third Horseman: Jumping to Conclusions</h2>
<p>The third horseman, jumping to conclusions, has been plaguing students’ communication efforts for as long as we can remember. This problem can manifest in two different (but related) symptoms, which we discuss separately below.</p>
<section id="symptom-1-making-recommendations-that-are-too-big" class="level3">
<h3 class="anchored" data-anchor-id="symptom-1-making-recommendations-that-are-too-big">Symptom 1: Making Recommendations that are “Too Big”</h3>
<p>Take a look at the following example:</p>
<blockquote class="blockquote">
<p><strong>Example 3.1</strong>: We conduct a clustering analysis on the customer base, and discover a high-spender group and a low-spender group. Therefore, our recommendation for growing the business is to encourage the low-spenders to spend more (e.g., via promotional campaigns).</p>
</blockquote>
<p>This is an example of making an out-sized recommendation based only on a very preliminary analysis. Just because some customers don’t spend a lot of money does not mean that they will automatically spend more if you ask. Why are they low-spenders in the first place? Is it because they truly have purchasing power but are waiting for better deals (in which case a promotional campaign might work), or is it because they don’t need to buy anything else (in which case promotional campaign is counter-productive)? Simply put, the prescriptive question of “what to do” for low-spenders <em>cannot</em> be faithfully answered based on an exploratory clustering analysis alone, period.</p>
<p>Business decision-making often involves going through incremental and inter-connected smaller steps. “Big” recommendations jump to the last step without making sure that intermediate questions have been properly considered.</p>
<p>This type of mistake likely stems from an overly narrow perception of what a recommendation can be. Especially when the analyses are exploratory in nature, it is perfectly reasonable to frame your recommendations as <em>questions</em>, rather than <em>actions</em>. Putting this to work, we can re-write the previous example as:</p>
<blockquote class="blockquote">
<p><strong>Example 3.2</strong>: We conduct a clustering analysis on the customer base, and discover a high-spender group and a low-spender group. Given the overall objective of growing the business. We believe it is necessary to dig deeper into the low-spender group and understand why they were not spending more money. This could involve examining their transaction data (if available) or conduct small scale interviews or focus groups. Once we have a better understanding of their behaviors, we will be able to make more informed decisions.</p>
</blockquote>
<p>Here, the recommendation is less about “what to do” and more about “which question to figure out next”. In a complicated business decision, narrowing down which questions to answer is just as valuable (if not more so) than answering the questions.</p>
</section>
<section id="symptom-2-making-recommendations-without-sufficient-evidence" class="level3">
<h3 class="anchored" data-anchor-id="symptom-2-making-recommendations-without-sufficient-evidence">Symptom 2: Making Recommendations without Sufficient Evidence</h3>
<p>A related symptom is making recommendations based not on specific evidence from your analyses, but based on what you “feel” is appropriate. Think about the following example:</p>
<blockquote class="blockquote">
<p><strong>Example 3.3</strong>: We have analyzed customer purchases of the focal product following broadcasting of TV ads, and our findings suggest that these TV ads are largely ineffective. Therefore, we recommend running Facebook ads to increase awareness.</p>
</blockquote>
<p>Here, unless you were secretly also analyzing online advertisement data related to the focal product and had reason to believe that Facebook ads would solve the awareness problem, then the recommendation is essentially wishful thinking. If you believe that advertising channel (i.e., TV vs.&nbsp;social media) is important, then your recommendation should focus on pointing out this possibility, rather than assuming it will work without evidence. For instance, you can say:</p>
<blockquote class="blockquote">
<p><strong>Example 3.4</strong>: We have analyzed customer purchases of the focal product following broadcasting of TV ads, and our findings suggest that these TV ads are largely ineffective. We recommend two directions for further exploration. First, we should conduct deeper analyses using TV viewership data to understand whether the lukewarm TV ads performance was because of suboptimal placement (e.g., the ads were aired during low-traffic hours) or because our target customers simply don’t watch these TV ads. Second, if the TV channel was the problem, we recommend exploring online advertising channels (such as Facebook ads) as a potential alternative, provided that we can run small-scale pilots to gauge their effectiveness.</p>
</blockquote>
</section>
</section>
<section id="the-four-horseman-lack-of-attention-to-aesthetics" class="level2">
<h2 class="anchored" data-anchor-id="the-four-horseman-lack-of-attention-to-aesthetics">The Four Horseman: Lack of Attention to Aesthetics</h2>
<p>The last horseman may appear “trivial” at first, but it bears outsized influences over the outcomes of your communication efforts. Humans are visual animals, and yes, beauty sells. Small aesthetics-related quirks in your executive summaries or presentation slides, which in retrospect often seem so obvious, can leave a bad impression on your audience. Below is a checklist of these “little big things”:</p>
<ul>
<li>Copy-paste raw coding outputs without careful re-formatting is almost always a bad idea;</li>
<li>List abbreviated variable names that no one except you can understand;</li>
<li>Present a visual (e.g., a figure or plot) without title or sensible names of x/y-axis;</li>
<li>Write a report with the title “Report”, or similarly, have a slide with the title “Some Results” – please provide more meaningful titles;</li>
<li>Typos and grammar errors;</li>
<li>…</li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>